{"mappings":"AAAA,MAAM,SAAS;IACb;IACA;AACF;AAEA,SAAS,cAAc,IAAI,EAAE,KAAK,EAAE,GAAG,QAAQ;IAC7C,OAAO;QACL;QACA,OAAO;YACL,GAAG,KAAK;YACR;;;MAGA,GACA,UAAU,SAAS,IAAI,CAAC,QACtB,OAAO,UAAU,WAAW,QAAQ,kBAAkB;QAE1D;IACF;AACF;AAEA,SAAS,kBAAkB,IAAI;IAC7B,OAAO;QACL,MAAM;QACN,OAAO;YACL,WAAW;YACX,UAAU,EAAE;QACd;IACF;AACF;AAEA,qCAAqC;AACrC,IAAI,iBAAiB;AACrB,IAAI,UAAU;AAEd,SAAS,cAAc,KAAK;IAC1B,MAAM,MACJ,MAAM,QAAQ,iBACV,SAAS,eAAe,MACxB,SAAS,cAAc,MAAM;IAEnC,qEAAqE;IACrE,OAAO,KAAK,MAAM,OACf,OAAO,CAAC,MAAQ,QAAQ,YACxB,QAAQ,CAAC,OAAU,GAAG,CAAC,KAAK,GAAG,MAAM,KAAK,CAAC,KAAK;IAEnD,OAAO;AACT;AAEA,SAAS,OAAO,OAAO,EAAE,SAAS;IAChC,8BAA8B;IAC9B,iBAAiB;QACf,KAAK;QACL,OAAO;YACL,UAAU;gBAAC;aAAQ;QACrB;IACF;AACF;AAEA;;AAEA,GACA,SAAS,UAAU,QAAQ;IACzB,IAAI,cAAc;IAElB,MAAO,kBAAkB,CAAC,YAAa;QACrC,iBAAiB,kBAAkB;QACnC,cAAc,SAAS,kBAAkB;IAC3C;IAEA,oBAAoB;AACtB;AACA;;AAEA,GACA,oBAAoB;AAEpB,SAAS,kBAAkB,KAAK;IAC9B,IAAI,CAAC,MAAM,KACT,MAAM,MAAM,cAAc;IAG5B,MAAM,WAAW,MAAM,MAAM;IAC7B,IAAI,QAAQ;IACZ,IAAI,cAAc;IAElB,MAAO,QAAQ,SAAS,MAAO;QAC7B,MAAM,UAAU,QAAQ,CAAC,MAAM;QAE/B,MAAM,WAAW;YACf,MAAM,QAAQ;YACd,OAAO,QAAQ;YACf,QAAQ;YACR,KAAK;QACP;QAEA,IAAI,UAAU,GACZ,MAAM,QAAQ;aAEd,YAAY,UAAU;QAGxB,cAAc;QACd;IACF;IAEA,IAAI,MAAM,OACR,OAAO,MAAM;IAGf,IAAI,YAAY;IAChB,MAAO,UAAW;QAChB,IAAI,UAAU,SACZ,OAAO,UAAU;QAEnB,YAAY,UAAU;IACxB;AACF;AAEA,8BAA8B,GAC9B,MAAM,wBACJ,AAFF,qBAEG;IAAI,WAAU;;;;;;;iBACb,AAHJ,qBAGK;;;;;;;GAAG,8BACJ,AAJJ,qBAIK;;;;;;;GAAE;AAOP,MAAM,OAAO,SAAS,eAAe;AAErC,OAAO,OAAO,SAAS","sources":["index.jsx"],"sourcesContent":["const Zitact = {\r\n  createElement,\r\n  render,\r\n};\r\n\r\nfunction createElement(type, props, ...children) {\r\n  return {\r\n    type,\r\n    props: {\r\n      ...props,\r\n      /* here we are checking this because the children of any react element can just be text\r\n       or number //////// (primitives).  So, we have to handle them seperately as while rendernig\r\n       recursively it can be a problem.\r\n      */\r\n      children: children.map((child) =>\r\n        typeof child === \"object\" ? child : createTextElement(child)\r\n      ),\r\n    },\r\n  };\r\n}\r\n\r\nfunction createTextElement(text) {\r\n  return {\r\n    type: \"TEXT_ELEMENT\",\r\n    props: {\r\n      nodeValue: text,\r\n      children: [],\r\n    },\r\n  };\r\n}\r\n\r\n// to keep track of text unit of work\r\nlet nextUnitOfWork = null;\r\nlet wipTree = null;\r\n\r\nfunction createDOMNode(fiber) {\r\n  const dom =\r\n    fiber.type == \"TEXT_ELEMENT\"\r\n      ? document.createTextNode(\"\")\r\n      : document.createElement(fiber.type);\r\n\r\n  //filering children from the props and assigning remaining to the dom\r\n  Object.keys(fiber.props)\r\n    .filter((key) => key !== \"children\")\r\n    .forEach((name) => (dom[name] = fiber.props[name]));\r\n\r\n  return dom;\r\n}\r\n\r\nfunction render(element, container) {\r\n  // TODO  set next unit of work\r\n  nextUnitOfWork = {\r\n    dom: container,\r\n    props: {\r\n      children: [element],\r\n    },\r\n  };\r\n}\r\n\r\n/*\r\nregulary performs small units of work \r\n*/\r\nfunction workLooop(deadline) {\r\n  let shouldYeild = false;\r\n\r\n  while (nextUnitOfWork && !shouldYeild) {\r\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\r\n    shouldYeild = deadline.timeRemaining() < 1;\r\n  }\r\n\r\n  requestIdleCallback(workLooop);\r\n}\r\n/* request idle callback is like settimeout but we don't define when to run the code \r\ninstead browser runs the code passed into it when the browser is idle\r\n*/\r\nrequestIdleCallback(workLooop);\r\n\r\nfunction performUnitOfWork(fiber) {\r\n  if (!fiber.dom) {\r\n    fiber.dom = createDOMNode(fiber);\r\n  }\r\n\r\n  const elements = fiber.props.children;\r\n  let index = 0;\r\n  let prevSibling = null;\r\n\r\n  while (index < elements.lenth) {\r\n    const element = elements[index];\r\n\r\n    const newFiber = {\r\n      type: element.type,\r\n      props: element.props,\r\n      parent: fiber,\r\n      dom: null,\r\n    };\r\n\r\n    if (index === 0) {\r\n      fiber.child = newFiber;\r\n    } else {\r\n      prevSibling.sibling = newFiber;\r\n    }\r\n\r\n    prevSibling = newFiber;\r\n    index++;\r\n  }\r\n\r\n  if (fiber.child) {\r\n    return fiber.child;\r\n  }\r\n\r\n  let nextFiber = fiber;\r\n  while (nextFiber) {\r\n    if (nextFiber.sibling) {\r\n      return nextFiber.sibling;\r\n    }\r\n    nextFiber = nextFiber.parent;\r\n  }\r\n}\r\n\r\n/** @jsx Zitact.createElement */\r\nconst element = (\r\n  <div className=\"id\">\r\n    <h1>Hello world</h1>\r\n    <p>\r\n      Lorem eiciendis eos laborum deserunt vero adipisci aliquid voluptates\r\n      ratione ex!\r\n    </p>\r\n  </div>\r\n);\r\n\r\nconst root = document.getElementById(\"root\");\r\n\r\nZitact.render(element, root);\r\n"],"names":[],"version":3,"file":"index.93d55021.js.map","sourceRoot":"/__parcel_source_root/"}